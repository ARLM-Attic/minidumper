using CommandLine;
using DumpWriter;
using Microsoft.Diagnostics.Runtime;
using Microsoft.Diagnostics.Runtime.Desktop;
using Microsoft.Diagnostics.Runtime.Interop;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace MiniDumper
{
    [Flags]
    public enum ThreadAccess : int
    {
        TERMINATE = (0x0001),
        SUSPEND_RESUME = (0x0002),
        GET_CONTEXT = (0x0008),
        SET_CONTEXT = (0x0010),
        SET_INFORMATION = (0x0020),
        QUERY_INFORMATION = (0x0040),
        SET_THREAD_TOKEN = (0x0080),
        IMPERSONATE = (0x0100),
        DIRECT_IMPERSONATION = (0x0200)
    }

    class Native
    {
#if X64
        public const int CONTEXT_SIZE = 1232;
#else
        public const int CONTEXT_SIZE = 716;
#endif
        [DllImport("kernel32.dll", CallingConvention = CallingConvention.Winapi, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool DebugSetProcessKillOnExit([In] bool flag);

        [DllImport("kernel32.dll", CallingConvention = CallingConvention.Winapi, SetLastError = true)]
        public static extern int GetProcessId([In] IntPtr hProcess);

        [DllImport("kernel32.dll")]
        public static extern IntPtr OpenThread(ThreadAccess dwDesiredAccess, bool bInheritHandle, uint dwThreadId);

        [DllImport("kernel32.dll")]
        public static extern bool GetThreadContext(IntPtr hThread, IntPtr lpContext);

        [DllImport("kernel32.dll", CallingConvention = CallingConvention.Winapi, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool CloseHandle([In] IntPtr hThread);
    }

    class MiniDumper : IDisposable
    {
        const uint CLRDBG_NOTIFICATION_EXCEPTION_CODE = 0x04242420;
        const uint CTRL_C_EXCEPTION_CODE = 0x40010005;
        const string dumpComment = "Generated by MiniDumper";

        private readonly DataTarget target;
        private readonly IDebugClient5 client;
        private readonly string dumpFolder;
        private readonly int pid;
        private readonly IntPtr hProcess;
        private readonly string processName;
        private readonly TextWriter logger;
        private readonly DumpType dumpType;
        private readonly bool writeAsync;
        private readonly Regex rgxFilter;
        private int numberOfDumpsTaken;

        public MiniDumper(IDebugClient5 client, string dumpFolder, int pid, IntPtr hProcess, String processName,
            TextWriter logger, DumpType dumpType, bool writeAsync, String filter)
        {
            this.client = client;
            this.dumpFolder = dumpFolder;
            this.pid = pid;
            this.hProcess = hProcess;
            this.processName = processName;
            this.logger = logger;
            this.dumpType = dumpType;
            this.writeAsync = writeAsync;
            this.rgxFilter = new Regex((filter ?? "*").Replace("*", ".*").Replace('?', '.'),
                RegexOptions.Singleline | RegexOptions.Compiled | RegexOptions.IgnoreCase);

            target = DataTarget.CreateFromDebuggerInterface(client);

            Console.WriteLine("CLR Version(s): {0}", String.Join(", ", target.ClrVersions.Select(clrver => clrver.Version.ToString())));
            Console.WriteLine();

        }

        public void DumpOnException(DebuggerListener o, EXCEPTION_RECORD ev)
        {
            if (ev.ExceptionCode == CLRDBG_NOTIFICATION_EXCEPTION_CODE) {
                // based on https://social.msdn.microsoft.com/Forums/vstudio/en-US/bca092d4-d2b5-49ef-8bbc-cbce2c67aa89/net-40-firstchance-exception-0x04242420?forum=clr
                // it's a "notification exception" and can be safely ignored
                return;
            }
            if (ev.ExceptionCode == CTRL_C_EXCEPTION_CODE) {
                // we will also ignore CTRL+C events
                return;
            }
            // print information about the exception (decode it)
            uint threadId;
            int hr = ((IDebugSystemObjects)client).GetCurrentThreadSystemId(out threadId);
            if (hr != 0) {
                Marshal.ThrowExceptionForHR(hr);
            }
            ClrException managedException = null;
            foreach (var clrver in target.ClrVersions) {
                var runtime = clrver.CreateRuntime();
                var thr = runtime.Threads.FirstOrDefault(t => t.OSThreadId == threadId);
                if (thr != null) {
                    managedException = thr.CurrentException;
                    break;
                }
            }
            var exceptionInfo = String.Format("{0:X}.{1} (\"{2}\")", ev.ExceptionCode,
                managedException != null ? managedException.Type.Name : "Native",
                managedException != null ? managedException.Message : "N/A");

            PrintTrace("Exception: " + exceptionInfo);

            var dumper = new DumpWriter.DumpWriter(target.DataReader, hProcess, pid, logger);
            Debug.Assert(dumper != null);
            Debug.Assert(rgxFilter != null);

            if (rgxFilter.IsMatch(exceptionInfo)) {
                /* I leave the Exception context for the future
                var pctx = Marshal.AllocHGlobal(Native.CONTEXT_SIZE);
                hr = ((IDebugAdvanced)client).GetThreadContext(pctx, Native.CONTEXT_SIZE);
                if (hr != 0) {
                    Marshal.ThrowExceptionForHR(hr);
                }
                IntPtr pev = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(EXCEPTION_RECORD_GENERIC)));
                Marshal.StructureToPtr(new EXCEPTION_RECORD_GENERIC {
                    ExceptionAddress = ev.ExceptionAddress,
                    ExceptionFlags = ev.ExceptionFlags,
                    ExceptionCode = ev.ExceptionCode,
                    ExceptionRecord = IntPtr.Zero,
                    NumberParameters = ev.NumberParameters,
                    ExceptionInformation = ev.ExceptionInformation
                }, pev, false);
                var excpointers = new EXCEPTION_POINTERS {
                    ExceptionRecord = pev,
                    ContextRecord = pctx
                };
                IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf(excpointers));
                Marshal.StructureToPtr(excpointers, ptr, false);
                var excinfo = new MINIDUMP_EXCEPTION_INFORMATION() {
                    ThreadId = threadId,
                    ClientPointers = false,
                    ExceptionPointers = ptr
                }; */
                MakeActualDump(null /* excinfo */);

                /*
                Marshal.FreeHGlobal(pev);
                Marshal.FreeHGlobal(pctx);
                Marshal.FreeHGlobal(ptr);*/
            }
        }

        public void DumpOnProcessExit(DebuggerListener o, int exitCode)
        {
            PrintTrace(String.Format("Process has terminated."));
            MakeActualDump();
        }

        private void MakeActualDump(MINIDUMP_EXCEPTION_INFORMATION? excinfo = null)
        {
            var dumper = new DumpWriter.DumpWriter(target.DataReader, hProcess, pid, logger);

            var filename = GetDumpFileName();
            PrintTrace(String.Format("Dumping process memory to file: {0}", filename));

            Interlocked.Increment(ref numberOfDumpsTaken);
            dumper.Dump(dumpType, filename, writeAsync, dumpComment, excinfo);
        }

        String GetDumpFileName()
        {
            var bfilename = Path.Combine(dumpFolder, String.Format("{0}_{1:yyMMdd_HHmmss}", processName, DateTime.Now));
            int cnt = 0;

            var filename = bfilename;
            while (true) {
                if (!File.Exists(filename + ".dmp")) {
                    break;
                }
                cnt++;
                filename = bfilename + "_" + cnt;
            }
            return filename + ".dmp";
        }

        void PrintTrace(String message)
        {
            Console.WriteLine("[{0:HH:mm.ss}] {1}", DateTime.Now, message);
        }

        public int NumberOfDumpsTaken
        {
            get { return numberOfDumpsTaken; }
            set { numberOfDumpsTaken = value; } // FIXME to remove
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (disposing) {
                target.Dispose();
            }
        }
    }
}
