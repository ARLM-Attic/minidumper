using DumpWriter;
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using VsChromium.Core.Win32.Debugging;

namespace MiniDumper
{
    [Flags]
    public enum ThreadAccess : int
    {
        TERMINATE = (0x0001),
        SUSPEND_RESUME = (0x0002),
        GET_CONTEXT = (0x0008),
        SET_CONTEXT = (0x0010),
        SET_INFORMATION = (0x0020),
        QUERY_INFORMATION = (0x0040),
        SET_THREAD_TOKEN = (0x0080),
        IMPERSONATE = (0x0100),
        DIRECT_IMPERSONATION = (0x0200)
    }

    class Native
    {
#if X64
        public const int CONTEXT_SIZE = 1232;
#else
        public const int CONTEXT_SIZE = 716;
#endif
    }

    class MiniDumper
    {
        const uint CLRDBG_NOTIFICATION_EXCEPTION_CODE = 0x04242420;
        const uint BREAKPOINT_CODE = 0x80000003;
        const uint CTRL_C_EXCEPTION_CODE = 0x40010005;
        const string dumpComment = "Generated by MiniDumper";

        private readonly string dumpFolder;
        private readonly int pid;
        private readonly IntPtr hProcess;
        private readonly string processName;
        private readonly TextWriter logger;
        private readonly DumpType dumpType;
        private readonly bool writeAsync;
        private readonly Regex rgxFilter;
        private int numberOfDumpsTaken;

        public MiniDumper(string dumpFolder, int pid, IntPtr hProcess, string processName,
            TextWriter logger, DumpType dumpType, bool writeAsync, string filter)
        {
            this.dumpFolder = dumpFolder;
            this.pid = pid;
            this.hProcess = hProcess;
            this.processName = processName;
            this.logger = logger;
            this.dumpType = dumpType;
            this.writeAsync = writeAsync;
            this.rgxFilter = new Regex((filter ?? "*").Replace("*", ".*").Replace('?', '.'),
                RegexOptions.Singleline | RegexOptions.Compiled | RegexOptions.IgnoreCase);
        }

        public void DumpOnException(EXCEPTION_RECORD ev)
        {
            if (ev.ExceptionCode == BREAKPOINT_CODE) {
                return;
            }
            if (ev.ExceptionCode == CLRDBG_NOTIFICATION_EXCEPTION_CODE) {
                // based on https://social.msdn.microsoft.com/Forums/vstudio/en-US/bca092d4-d2b5-49ef-8bbc-cbce2c67aa89/net-40-firstchance-exception-0x04242420?forum=clr
                // it's a "notification exception" and can be safely ignored
                return;
            }
            if (ev.ExceptionCode == CTRL_C_EXCEPTION_CODE) {
                // we will also ignore CTRL+C events
                return;
            }
            // print information about the exception (decode it)
            /*
            uint threadId;
            int hr = ((IDebugSystemObjects)client).GetCurrentThreadSystemId(out threadId);
            if (hr != 0) {
                Marshal.ThrowExceptionForHR(hr);
            }
            ClrException managedException = null;
            foreach (var clrver in target.ClrVersions) {
                var runtime = clrver.CreateRuntime();
                var thr = runtime.Threads.FirstOrDefault(t => t.OSThreadId == threadId);
                if (thr != null) {
                    managedException = thr.CurrentException;
                    break;
                }
            }
            var exceptionInfo = String.Format("{0:X}.{1} (\"{2}\")", ev.ExceptionCode,
                managedException != null ? managedException.Type.Name : "Native",
                managedException != null ? managedException.Message : "N/A");

            PrintTrace("Exception: " + exceptionInfo);

            var dumper = new DumpWriter.DumpWriter(target.DataReader, hProcess, pid, logger);
            Debug.Assert(dumper != null);
            Debug.Assert(rgxFilter != null);

            if (rgxFilter.IsMatch(exceptionInfo)) {
            */
                /* I leave the Exception context for the future
                var pctx = Marshal.AllocHGlobal(Native.CONTEXT_SIZE);
                hr = ((IDebugAdvanced)client).GetThreadContext(pctx, Native.CONTEXT_SIZE);
                if (hr != 0) {
                    Marshal.ThrowExceptionForHR(hr);
                }
                IntPtr pev = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(EXCEPTION_RECORD_GENERIC)));
                Marshal.StructureToPtr(new EXCEPTION_RECORD_GENERIC {
                    ExceptionAddress = ev.ExceptionAddress,
                    ExceptionFlags = ev.ExceptionFlags,
                    ExceptionCode = ev.ExceptionCode,
                    ExceptionRecord = IntPtr.Zero,
                    NumberParameters = ev.NumberParameters,
                    ExceptionInformation = ev.ExceptionInformation
                }, pev, false);
                var excpointers = new EXCEPTION_POINTERS {
                    ExceptionRecord = pev,
                    ContextRecord = pctx
                };
                IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf(excpointers));
                Marshal.StructureToPtr(excpointers, ptr, false);
                var excinfo = new MINIDUMP_EXCEPTION_INFORMATION() {
                    ThreadId = threadId,
                    ClientPointers = false,
                    ExceptionPointers = ptr
                }; */
                MakeActualDump(null /* excinfo */);

                /*
                Marshal.FreeHGlobal(pev);
                Marshal.FreeHGlobal(pctx);
                Marshal.FreeHGlobal(ptr);*/
                /*
            }*/
        }

        public void DumpOnProcessExit(uint exitCode)
        {
            PrintTrace(string.Format("Process has terminated."));
            MakeActualDump();
        }

        private void MakeActualDump(MINIDUMP_EXCEPTION_INFORMATION? excinfo = null)
        {
            //var dumper = new DumpWriter.DumpWriter(hProcess, pid, logger);
            var dumper = new DumpWriter.DumpWriter(logger);

            var filename = GetDumpFileName();
            PrintTrace(string.Format("Dumping process memory to file: {0}", filename));

            Interlocked.Increment(ref numberOfDumpsTaken);
            dumper.Dump(pid, hProcess, dumpType, filename, writeAsync, dumpComment);
        }

        String GetDumpFileName()
        {
            var bfilename = Path.Combine(dumpFolder, string.Format("{0}_{1:yyMMdd_HHmmss}", processName, DateTime.Now));
            int cnt = 0;

            var filename = bfilename;
            while (true) {
                if (!File.Exists(filename + ".dmp")) {
                    break;
                }
                cnt++;
                filename = bfilename + "_" + cnt;
            }
            return filename + ".dmp";
        }

        void PrintTrace(string message)
        {
            Console.WriteLine("[{0:HH:mm.ss}] {1}", DateTime.Now, message);
        }

        public int NumberOfDumpsTaken
        {
            get { return numberOfDumpsTaken; }
        }
    }
}
