using CommandLine;
using DumpWriter;
using Microsoft.Diagnostics.Runtime;
using Microsoft.Diagnostics.Runtime.Desktop;
using Microsoft.Diagnostics.Runtime.Interop;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;

namespace MiniDumper
{
    class Native
    {
        [DllImport("kernel32.dll", CallingConvention = CallingConvention.Winapi, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool DebugSetProcessKillOnExit([In] bool flag);

        [DllImport("kernel32.dll", CallingConvention = CallingConvention.Winapi, SetLastError = true)]
        public static extern int GetProcessId([In] IntPtr hProcess);
    }

    class Program : IDisposable
    {
        const uint CLRDBG_NOTIFICATION_EXCEPTION_CODE = 0x04242420;
        const uint CTRL_C_EXCEPTION_CODE = 0x40010005;
        const string dumpComment = "Generated by MiniDumper";

        private DumpWriter.DumpWriter dumper;
        private DataTarget target;
        private IDebugClient5 client;
        private string dumpFolder;
        private int pid;
        private IntPtr hProcess;
        private string processName;
        private TextWriter logger;
        private DumpType dumpType;
        private bool writeAsync, dumpOnTerminate;
        private int numberOfDumps;
        private Regex rgxFilter;

        private bool detached;

        static void Main(string[] args)
        {
            try {
                var result = Parser.Default.ParseArguments<CommandLineOptions>(args);
                result.WithParsed(new Program().TakeDumps);
            } catch (Exception ex) {
                Console.Error.WriteLine("ERROR: {0}", ex.Message);
            }
        }

        void TakeDumps(CommandLineOptions options)
        {
            SetupEnvironmentForDump(options);

            // main debug event loop
            var control = (IDebugControl2)client;
            Debug.Assert(control != null);
            DEBUG_STATUS status;
            do {
                int hr = control.WaitForEvent(0, 1000);
                if (detached) {
                    // we are done
                    return;
                }
                if (hr < 0 && (uint)hr != 0x8000000A) {
                    throw new ClrDiagnosticsException(String.Format("IDebugControl::WaitForEvent: 0x{0:x8}", hr), ClrDiagnosticsException.HR.DebuggerError);
                }

                hr = control.GetExecutionStatus(out status);
                if (hr < 0)
                    throw new ClrDiagnosticsException(String.Format("IDebugControl::GetExecutionStatus: 0x{0:x8}", hr), ClrDiagnosticsException.HR.DebuggerError);
            } while (status != DEBUG_STATUS.NO_DEBUGGEE && !detached);
        }

        void SetupDebugClient(CommandLineOptions options)
        {
            Guid guid = new Guid("27fe5639-8407-4f47-8364-ee118fb08ac8");
            object obj;
            NativeMethods.DebugCreate(ref guid, out obj);
            client = (IDebugClient5)obj;

            SetupListener(client);

            if (options.ProcessInfo != null) {
                if (Int32.TryParse(options.ProcessInfo, out pid)) {
                    hProcess = Process.GetProcessById(pid).Handle;
                } else {
                    // not numeric - let's try to find it by name
                    var procs = Process.GetProcessesByName(options.ProcessInfo);
                    if (procs.Length == 1) {
                        pid = procs[0].Id;
                        hProcess = procs[0].Handle;
                    }
                    if (procs.Length > 1) {
                        throw new ArgumentException("There is more than one process with the specified name");
                    }
                }
                if (pid > 0) {
                    Debug.Assert(hProcess != IntPtr.Zero);
                    int hr;
                    // process found - let's attach to it
                    hr = client.AttachProcess(0, (uint)pid, DEBUG_ATTACH.DEFAULT);
                    if (hr < 0) {
                        Marshal.ThrowExceptionForHR(hr);
                    }
                    return;
                }
                if (!String.IsNullOrEmpty(options.DumpFolderForNewlyStartedProcess)) {
                    // final try - let's try creating it (but only if -x option is set)
                    var commandLine = options.ProcessInfo + " " + String.Join(" ", options.Args ?? new string[0]);
                    var createProcessOptions = new DEBUG_CREATE_PROCESS_OPTIONS();
                    createProcessOptions.CreateFlags = DEBUG_CREATE_PROCESS.DEBUG_ONLY_THIS_PROCESS;
                    int hr = client.CreateProcessAndAttach2(0, commandLine, ref createProcessOptions,
                        (uint)Marshal.SizeOf(typeof(DEBUG_CREATE_PROCESS_OPTIONS)), null, null, 0, DEBUG_ATTACH.DEFAULT);
                    if (hr < 0) {
                        Marshal.ThrowExceptionForHR(hr);
                    }
                    // wait for the first event (create process)
                    hr = ((IDebugControl2)client).WaitForEvent(0, 1000);
                    if (hr < 0 && (uint)hr != 0x8000000A) {
                        Marshal.ThrowExceptionForHR(hr);
                    }
                    return;
                }
            }
            throw new ArgumentException("Something is wrong with the arguments - I wasn't able to create a process.");
        }

        String GetDumpFileName()
        {
            return Path.Combine(dumpFolder, String.Format("{0}_{1:yyMMdd_HHmmss}.dmp", processName, DateTime.Now));
        }

        void PrintTrace(String message)
        {
            Console.WriteLine("[{0:HH:mm.ss}] {1}", DateTime.Now, message);
        }

        void SetupListener(IDebugClient5 client)
        {
            var listener = new DebuggerListener(logger);
            listener.CreateProcessEvent += (d, ev) => {
                hProcess = (IntPtr)ev.Handle;
                pid = Native.GetProcessId(hProcess);
            };
            listener.FirstChanceExceptionEvent += (d, ev) => {
                if (ev.ExceptionCode == CLRDBG_NOTIFICATION_EXCEPTION_CODE) {
                    // based on https://social.msdn.microsoft.com/Forums/vstudio/en-US/bca092d4-d2b5-49ef-8bbc-cbce2c67aa89/net-40-firstchance-exception-0x04242420?forum=clr
                    // it's a "notification exception" and can be safely ignored
                    return;
                }
                if (ev.ExceptionCode == CTRL_C_EXCEPTION_CODE) {
                    // we will also ignore CTRL+C events
                    return;
                }
                // FIXME print information about the exception (decode it)
                uint threadId;
                int hr = ((IDebugSystemObjects)client).GetCurrentThreadSystemId(out threadId);
                if (hr != 0) {
                    Marshal.ThrowExceptionForHR(hr);
                }
                ClrException managedException = null;
                foreach (var clrver in target.ClrVersions) {
                    var runtime = clrver.CreateRuntime();
                    var thr = runtime.Threads.FirstOrDefault(t => t.OSThreadId == threadId);
                    if (thr != null) {
                        managedException = thr.CurrentException;
                        break;
                    }
                }
                var exceptionInfo = String.Format("{0:X}.{1} (\"{2}\")", ev.ExceptionCode,
                    managedException != null ? managedException.Type.Name : "Native",
                    managedException != null ? managedException.Message : "N/A");

                PrintTrace("Exception: " + exceptionInfo);

                Debug.Assert(dumper != null);
                Debug.Assert(rgxFilter != null);

                if (rgxFilter.IsMatch(exceptionInfo)) {
                    var filename = GetDumpFileName();
                    PrintTrace(String.Format("Dumping process memory to file: {0}", filename));
                    // FIXME dump must have the exception record set
                    //dumper.Dump(dumpType, filename, writeAsync, dumpComment);
                }
            };
            listener.ExitProcessEvent += (d, ev) => {
                detached = true;
                PrintTrace(String.Format("Process has terminated."));
                if (dumpOnTerminate) {
                    Debug.Assert(dumper != null);
                    // FIXME dump
                }
            };

            client.SetEventCallbacks(listener);
            client.SetOutputCallbacks(listener);
        }

        private static DumpType OptionToDumpType(CommandLineOptions options)
        {
            if (options.MinimalDump)
                return DumpType.Minimal;
            if (options.MinimalDumpWithCLRHeap)
                return DumpType.MinimalWithFullCLRHeap;
            if (options.FullDump)
                return DumpType.FullMemory;

            // Should never get here
            return DumpType.MinimalWithFullCLRHeap;
        }

        private void SetupEnvironmentForDump(CommandLineOptions options)
        {
            // some basic options
            writeAsync = options.Async;
            numberOfDumps = options.NumberOfDumps;
            logger = options.Verbose ? Console.Out : TextWriter.Null;
            dumpOnTerminate = options.DumpOnProcessTerminate;
            rgxFilter = new Regex((options.ExceptionFilter ?? "*").Replace("*", ".*").Replace('?', '.'),
                RegexOptions.Singleline | RegexOptions.Compiled | RegexOptions.IgnoreCase);

            // rules for dumps
            int set = 0;
            set += options.FullDump ? 1 : 0;
            set += options.MinimalDump ? 1 : 0;
            set += options.MinimalDumpWithCLRHeap ? 1 : 0;
            if (set == 0) {
                throw new ArgumentException("No dump option specified");
            }
            if (set > 1) {
                throw new ArgumentException("More than one dump option specified");
            }
            dumpType = OptionToDumpType(options);

            if (String.IsNullOrEmpty(options.ProcessInfo)) {
                throw new ArgumentException("Either a process id or process name is required");
            }

            // file name and dump folder
            dumpFolder = options.DumpFolderForNewlyStartedProcess ?? Assembly.GetExecutingAssembly().CodeBase;
            if (!Directory.Exists(dumpFolder)) {
                throw new ArgumentException("The specified dump folder does not exist.");
            }

            SetupDebugClient(options);

            Console.CancelKeyPress += (o, ev) => {
                PrintTrace("Ctrl + C received - detaching from a process");
                if (!detached) {
                    Debug.Assert(client != null);
                    int hr = client.DetachCurrentProcess();
                    if (hr != 0) {
                        Marshal.ThrowExceptionForHR(hr);
                    }
                }
            };

            // get information about the process
            var proc = Process.GetProcessById(pid);
            processName = proc.ProcessName;

            // FIXME gather information about the process, extract 64bit version and dbghelp library

            Console.WriteLine("MiniDumper - writes .NET process dump files");
            Console.WriteLine("Copyright (C) 2015 Sasha Goldstein (@goldshtn)");
            Console.WriteLine();
            Console.WriteLine("With contributions from Sebastian Solnica (@lowleveldesign)");
            Console.WriteLine();

            Console.WriteLine("Process:             {0} ({1})", proc.ProcessName, proc.Id);
            Console.WriteLine("Exception monitor:   {0}", options.DumpOnException == 1 ? "First Chance+Unhandled" :
                (options.DumpOnException == 2 ? "Unhandled" : "Disabled"));
            Console.WriteLine("Exception filter:    {0}", options.ExceptionFilter ?? "*");
            Console.WriteLine("Dump folder:         {0}", dumpFolder);
            Console.WriteLine("Number of dumps:     {0}", numberOfDumps);
            Console.WriteLine("Dump filename/mask:  PROCESSNAME_YYMMDD_HHMMSS");
            Console.WriteLine("Terminal monitor:    {0}", options.DumpOnProcessTerminate ? "Enabled" : "Disabled");
            Console.WriteLine("Debug output:        {0}", options.Verbose ? "Enabled" : "Disabled");
            Console.WriteLine();
            Console.WriteLine("Press Ctrl-C to end monitoring without terminating the process.");
            Console.WriteLine();

            target = DataTarget.CreateFromDebuggerInterface(client);

            Console.WriteLine("CLR Version(s): {0}", String.Join(", ", target.ClrVersions.Select(clrver => clrver.Version.ToString())));
            Console.WriteLine();

            dumper = new DumpWriter.DumpWriter(target.DataReader, hProcess, pid, logger);

        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (disposing) {
                target.Dispose();
            }
        }


    }
}
