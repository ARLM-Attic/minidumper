using CommandLine;
using DumpWriter;
using Microsoft.Diagnostics.Runtime;
using Microsoft.Diagnostics.Runtime.Desktop;
using Microsoft.Diagnostics.Runtime.Interop;
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;

namespace MiniDumper
{
    class Native
    {
        [DllImport("kernel32.dll", CallingConvention = CallingConvention.Winapi, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool DebugSetProcessKillOnExit([In] bool flag);

        [DllImport("kernel32.dll", CallingConvention = CallingConvention.Winapi, SetLastError = true)]
        public static extern int GetProcessId([In] IntPtr hProcess);
    }

    class Program : IDisposable
    {
        const string dumpComment = "Generated by MiniDumper";
        private DumpWriter.DumpWriter dumper;
        private string dumpFolder;
        private int pid;
        private IntPtr hProcess;
        private string processName;
        private IDebugClient5 client;
        private TextWriter logger;
        private DumpType dumpType;
        private bool writeAsync, dumpOnTerminate;
        private int numberOfDumps;

        void SetupDebugClient(CommandLineOptions options)
        {
            Guid guid = new Guid("27fe5639-8407-4f47-8364-ee118fb08ac8");
            object obj;
            NativeMethods.DebugCreate(ref guid, out obj);
            client = (IDebugClient5)obj;

            if (options.ProcessInfo != null)
            {
                // FIXME: what about the initial breakpoint?
                if (Int32.TryParse(options.ProcessInfo, out pid))
                {
                    hProcess = Process.GetProcessById(pid).Handle;
                }
                // not numeric - let's try to find it by name
                var procs = Process.GetProcessesByName(options.ProcessInfo);
                if (procs.Length == 1)
                {
                    pid = procs[0].Id;
                    hProcess = procs[0].Handle;
                    processName = procs[0].ProcessName;
                }
                if (procs.Length > 1)
                {
                    throw new ArgumentException("There is more than one process with the specified name");
                }
                int hr;
                if (procs.Length == 1)
                {
                    // process found - let's attach to it
                    hr = client.AttachProcess(0, (uint)pid, DEBUG_ATTACH.DEFAULT);
                    if (hr < 0)
                    {
                        Marshal.ThrowExceptionForHR(hr);
                    }
                    return;
                }
                if (!String.IsNullOrEmpty(options.DumpFolderForNewlyStartedProcess))
                {
                    // final try - let's try creating it (but only if -x option is set)
                    var commandLine = options.ProcessInfo + " " + String.Join(" ", options.Args ?? new string[0]);
                    var createProcessOptions = new DEBUG_CREATE_PROCESS_OPTIONS();
                    createProcessOptions.CreateFlags = (DEBUG_CREATE_PROCESS)1;
                    hr = client.CreateProcessAndAttach2(0, commandLine, ref createProcessOptions,
                        (uint)Marshal.SizeOf(typeof(DEBUG_CREATE_PROCESS_OPTIONS)), null, null, 0, DEBUG_ATTACH.DEFAULT);
                    if (hr < 0)
                    {
                        Marshal.ThrowExceptionForHR(hr);
                    }
                    return;
                }
            }
            throw new ArgumentException("Something is wrong with the arguments - I wasn't able to create a process.");
        }

        void StartListner(IDebugClient5 client)
        {
            var listener = new DebuggerListener(logger);
            IntPtr hProcess = IntPtr.Zero; int pid = 0;
            listener.CreateProcessEvent += (d, ev) => {
                hProcess = (IntPtr)ev.Handle;
                pid = Native.GetProcessId(hProcess);
                processName = Path.GetFileName(ev.ImageName);
            };
            listener.FirstChanceExceptionEvent += (d, ev) => {
                if (ev.ExceptionCode == 69477408)
                {
                    // FIXME to remove (it is probably breakpoint - check it)
                    return;
                }
                //dumper.Dump(dumpType, fileName, writeAsync, dumpComment);
            };
            listener.ExitProcessEvent += (d, ev) => {
                if (dumpOnTerminate)
                {
                    // FIXME dump
                }
            };

            client.SetEventCallbacks(listener);
            client.SetOutputCallbacks(listener);

            // main debug event loop
            var control = (IDebugControl2)client;
            Debug.Assert(control != null);
            DEBUG_STATUS status;
            do
            {
                int hr = control.WaitForEvent(0, 1000);
                if (hr < 0 && (uint)hr != 0x8000000A)
                {
                    throw new ClrDiagnosticsException(String.Format("IDebugControl::WaitForEvent: 0x{0:x8}", hr), ClrDiagnosticsException.HR.DebuggerError);
                }

                hr = control.GetExecutionStatus(out status);
                if (hr < 0)
                    throw new ClrDiagnosticsException(String.Format("IDebugControl::GetExecutionStatus: 0x{0:x8}", hr), ClrDiagnosticsException.HR.DebuggerError);
            } while (status != DEBUG_STATUS.NO_DEBUGGEE);
        }

        void TakeDumps(CommandLineOptions options)
        {
            ParseAndValidateOptions(options);

            using (var target = DataTarget.CreateFromDebuggerInterface(client))
            {
                dumper = new DumpWriter.DumpWriter(target.DataReader, hProcess, pid, logger);

                var dbgctrl = client as IDebugControl2;
                if (dbgctrl != null)
                {
                    // setup listener
                    StartListner(client);
                }
                else
                {
                    // FIXME: for immediate dumps (live or full memory dump convertions)
                }
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (disposing)
            {
            }
        }

        private static DumpType OptionToDumpType(CommandLineOptions options)
        {
            if (options.MinimalDump)
                return DumpType.Minimal;
            if (options.MinimalDumpWithCLRHeap)
                return DumpType.MinimalWithFullCLRHeap;
            if (options.FullDump)
                return DumpType.FullMemory;

            // Should never get here
            return DumpType.MinimalWithFullCLRHeap;
        }

        private void ParseAndValidateOptions(CommandLineOptions options)
        {
            // some basic options
            writeAsync = options.Async;
            numberOfDumps = options.NumberOfDumps;
            logger = options.Verbose ? Console.Out : TextWriter.Null;
            dumpOnTerminate = options.DumpOnProcessTerminate;

            // rules for dumps
            int set = 0;
            set += options.FullDump ? 1 : 0;
            set += options.MinimalDump ? 1 : 0;
            set += options.MinimalDumpWithCLRHeap ? 1 : 0;
            if (set == 0) {
                throw new ArgumentException("No dump option specified");
            }
            if (set > 1) {
                throw new ArgumentException("More than one dump option specified");
            }
            dumpType = OptionToDumpType(options);

            if (String.IsNullOrEmpty(options.ProcessInfo)) {
                throw new ArgumentException("Either a process id or process name is required");
            }

            // file name and dump folder
            dumpFolder = options.DumpFolderForNewlyStartedProcess ?? Assembly.GetExecutingAssembly().CodeBase;
            if (File.Exists(dumpFolder)) {
                throw new ArgumentException("The specified file already exists");
            }

            SetupDebugClient(options);

            // FIXME gather information about the process, extract 64bit version and dbghelp library

            Console.WriteLine("MiniDumper - writes .NET process dump files");
            Console.WriteLine("Copyright (C) 2015 Sasha Goldstein (@goldshtn)");
            Console.WriteLine();
            Console.WriteLine("With contributions from Sebastian Solnica (@lowleveldesign)");
            Console.WriteLine();


            Console.WriteLine("Process info:       {0}", options.ProcessInfo);
            Console.WriteLine("Exception monitor:  {0}", options.DumpOnException == 1 ? "First Chance+Unhandled" :
                (options.DumpOnException == 2 ? "Unhandled" : "Disabled"));
            Console.WriteLine("Exception filter:   {0}", options.ExceptionFilter ?? "*");
            Console.WriteLine("Dump folder:        {0}", dumpFolder);
            Console.WriteLine("Number of dumps:    {0}", numberOfDumps);
            Console.WriteLine("Dump filename/mask: PROCESSNAME_YYMMDD_HHMMSS");
            Console.WriteLine("Terminal monitor:   {0}", options.DumpOnProcessTerminate ? "Enabled" : "Disabled");
            Console.WriteLine("Debug output:       {0}", options.Verbose ? "Enabled" : "Disabled");
            Console.WriteLine();
            Console.WriteLine("Press Ctrl-C to end monitoring without terminating the process.");
            Console.WriteLine();
        }

        static void Main(string[] args)
        {
            try
            {
                var result = Parser.Default.ParseArguments<CommandLineOptions>(args);
                result.WithParsed(new Program().TakeDumps);
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine("ERROR: {0}", ex.Message);
            }
        }

    }
}
